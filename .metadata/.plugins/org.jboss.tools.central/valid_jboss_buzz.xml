<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>How to remotely query indexed caches in Data Grid 8</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/30/remotely-query-indexed-caches-data-grid-8" /><author><name>Alexander Barbosa Ayala</name></author><id>5cab99e0-6a2c-4bf4-9130-268868f0c3d4</id><updated>2022-11-30T07:00:00Z</updated><published>2022-11-30T07:00:00Z</published><summary type="html">&lt;p&gt;The &lt;a href="https://www.redhat.com/en/technologies/jboss-middleware/data-grid"&gt;Red Hat Data Grid&lt;/a&gt; is a hosted data storage platform that offers different levels of caching for fast access to data in memory. Well-chosen indexes allow the data store to fetch results faster than non-indexed caches. This article demonstrates how to create indexes in Data Grid and use them in a &lt;a href="https://developers.redhat.com/topics/enterprise-java"&gt;Java&lt;/a&gt; application built on &lt;a href="https://developers.redhat.com/topics/spring-boot"&gt;Spring Boot&lt;/a&gt;. Then we will run and test the application in a &lt;a href="https://developers.redhat.com/topics/containers"&gt;container&lt;/a&gt; on &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat OpenShift&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Understanding indexed cache structure&lt;/h2&gt; &lt;p&gt;To use indexing, you need to define the indexed entity both in Data Grid and on the application side. The example in this article uses a &lt;code&gt;Book&lt;/code&gt; entity, shown in Figure 1.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig1_23.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig1_23.png?itok=e2VVO2k2" width="141" height="121" alt="The Book object contains three fields for which we create indexes." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1: The Book object contains three fields for which we create indexes. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;The &lt;code&gt;Book&lt;/code&gt; structure needs to be mapped on either side of the communication, as a Java object in the application (&lt;code&gt;Book.java&lt;/code&gt;) and as a &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html/cache_encoding_and_marshalling/cache-encoding#protobuf-encoding_storage-formats"&gt;Protocol Buffers (protobuf) schema&lt;/a&gt; in the cache. Figure 2 shows the relationship between all the components using the cache.&lt;/p&gt; &lt;p&gt; &lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/DataGrid-Fig2.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/DataGrid-Fig2.png?itok=oYNEMgWX" width="600" height="235" alt="A relational diagram of the Spring Boot application and Data Grid." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 2: Both the Spring Boot application and Data Grid define the structure of the Book. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;The &lt;code&gt;Book.java&lt;/code&gt; class defines the Book entity fields using the &lt;code&gt;@Protodoc&lt;/code&gt; and &lt;code&gt;@Protofiled&lt;/code&gt; annotations as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package com.redhat.dg8remote.controller; ... @ProtoDoc("@Indexed") public class Book { @ProtoDoc("@Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO)") @ProtoField(number = 1) String title; @ProtoDoc("@Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO)") @ProtoField(number = 2) String description; @ProtoDoc("@Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO)") @ProtoField(number = 3, defaultValue = "0") int publicationYear; @ProtoFactory Book(String title, String description, int publicationYear) { this.title = title; this.description = description; this.publicationYear = publicationYear; } }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;book.proto&lt;/code&gt; schema file defines the same fields as &lt;code&gt;Book.java&lt;/code&gt; does, but using the syntax for a protobuf schema:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-javascript"&gt;syntax = "proto2"; package book_sample; /** * @Indexed */ message Book { /** * @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */ optional string title = 1; /** * @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */ optional string description = 2; /** * @Field(index=Index.YES, analyze = Analyze.YES, store = Store.NO) */ optional int32 publicationYear = 3 [default = 0]; }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To use indexes, you also need to make changes in the XML definition of the Data Grid cache.&lt;/p&gt; &lt;p&gt;First, you need to add an &lt;code&gt;&lt;indexing&gt;&lt;/code&gt; element. This element causes the data marshaling process to use the &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html/cache_encoding_and_marshalling/marshalling_user_types#protostream_marshalling"&gt;ProtoStream library&lt;/a&gt; to handle protobufs. Then, define the  &lt;code&gt;&lt;indexed-entity&gt;&lt;/code&gt; element referring to the &lt;code&gt;&lt;package&gt;.&lt;entity-name&gt;&lt;/code&gt; structure. &lt;/p&gt; &lt;p&gt;For the current article the indexed cache should be configured as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt; &lt;replicated-cache name="books" mode="SYNC" statistics="true"&gt; &lt;indexing enabled="true"&gt; &lt;indexed-entities&gt; &lt;indexed-entity&gt;book_sample.Book&lt;/indexed-entity&gt; &lt;/indexed-entities&gt; &lt;/indexing&gt; &lt;/replicated-cache&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Note that the default cache &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html/cache_encoding_and_marshalling/cache-encoding#encoding-caches-protostream_storage-formats"&gt;encoding&lt;/a&gt; is &lt;code&gt;application/x-protostream. &lt;/code&gt;Therefore, no additional elements are required for this cache configuration.&lt;/p&gt; &lt;h2&gt;The remote query application&lt;/h2&gt; &lt;p&gt;The current query demo application is based on the example provided in the Data Grid documentation section &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html-single/querying_data_grid_caches/index#querying-hot-rod_query-remote"&gt;Querying caches from Hot Rod Java clients&lt;/a&gt;. I have adapted this application and configured it to run as a Spring Boot application. The application can run standalone or be deployed in a containerized environment such as OpenShift. The code source can be found in the &lt;a href="https://github.com/alexbarbosa1989/dg8remote/tree/openshift/src/main/java/com/redhat/dg8remote"&gt;dg8remote&lt;/a&gt; demo project on GitHub.&lt;/p&gt; &lt;p&gt;The application defines three classes for remote query and entity definition. A fourth class implements data marshaling (Figure 3).&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig3_8.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig3_8.png?itok=w5j4CWH-" width="287" height="461" alt="The example application defines three classes for queries and one class for data marshaling." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 3: The example application defines three classes for queries and one class for data marshaling. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;The classes have the following purposes:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/alexbarbosa1989/dg8remote/blob/openshift/src/main/java/com/redhat/dg8remote/controller/Book.java"&gt;Book.java&lt;/a&gt;: Contains the fields for the Book entity. Each field has &lt;code&gt;@Protodoc&lt;/code&gt; and &lt;code&gt;@Protofield&lt;/code&gt; annotations for indexing purposes.&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/alexbarbosa1989/dg8remote/blob/openshift/src/main/java/com/redhat/dg8remote/controller/RemoteQueryInitializer.java"&gt;RemoteQueryInitializer.java&lt;/a&gt;: An interface that contains the protobuf schema details, such as a &lt;code&gt;Book&lt;/code&gt; class reference for automatic proto file generation, package name, proto file name, and path.&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/alexbarbosa1989/dg8remote/blob/openshift/src/main/java/com/redhat/dg8remote/controller/RemoteQuery.java"&gt;RemoteQuery.java&lt;/a&gt;: Contains the exposed REST service that returns the query results. The constructor uploads the generated &lt;code&gt;book.proto&lt;/code&gt; file in the Remote Data Grid instance. This class also tells the compiler to generate a &lt;code&gt;RemoteQueryInitializerImp&lt;/code&gt; schema.&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/alexbarbosa1989/dg8remote/blob/openshift/src/main/java/com/redhat/dg8remote/InfinispanConfiguration.java"&gt;InfinispanConfiguration.java&lt;/a&gt;: Adds a marshaller, which is needed in the client to serialize the application's object.&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;Running the remote query service&lt;/h2&gt; &lt;p&gt;For the current demo, deploy the Data Grid cache cluster and the remote query service on OpenShift. The caches and the service are in separate projects, just like the original version of the application described in the article &lt;a href="https://developers.redhat.com/articles/2022/05/31/integrate-spring-boot-application-red-hat-data-grid"&gt;Integrate a Spring Boot application with Red Hat Data Grid&lt;/a&gt;.&lt;/p&gt; &lt;h3&gt;Environment details&lt;/h3&gt; &lt;p&gt;I used the following versions of the components that make up this example:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Red Hat Data Grid 8.3&lt;/li&gt; &lt;li&gt;Red Hat OpenShift 4.10&lt;/li&gt; &lt;li&gt;Spring Boot 2.7.2&lt;/li&gt; &lt;li&gt;Java 11&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;Defining the Data Grid cluster custom resource&lt;/h2&gt; &lt;p&gt;The previous article explains how the Data Grid cluster is generated using an Operator. We have to make one change in our example to expose the cluster through the LoadBalancer. Here is how our configuration looks:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: infinispan.org/v1 kind: Infinispan metadata: name: infinispan-test namespace: dgtest spec: expose: type: LoadBalancer service: type: DataGrid replicas: 2&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Creating the book cache&lt;/h2&gt; &lt;p&gt;To create the cache, go to the &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html-single/data_grid_operator_guide/index#connecting-console_clients"&gt;Data Grid Web Console&lt;/a&gt; in a browser, then create a custom cache named &lt;code&gt;books&lt;/code&gt; using the following JSON code. Include the &lt;code&gt;book_sample.Book&lt;/code&gt; indexed entity as shown. Figure 4 shows where to enter the JSON.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-json"&gt;{ "replicated-cache": { "mode": "SYNC", "statistics": true, "indexing": { "enabled": true, "indexed-entities": [ "book_sample.Book" ] } } }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Finish by clicking the &lt;strong&gt;Create&lt;/strong&gt; button:&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig4_6.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig4_6.png?itok=OxmLvCp0" width="600" height="312" alt="Enter the JSON configuration and create the books cache." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 4: Enter the JSON configuration and create the books cache. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;There are other ways to create caches, detailed in &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html-single/data_grid_operator_guide/index#creating-caches"&gt;Data Grid Documentation&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Configuring the application to use the data grid cluster&lt;/h2&gt; &lt;p&gt;Clone the remote query service project:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ git clone -b openshift https://github.com/alexbarbosa1989/dg8remote&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Refer to &lt;a href="https://developers.redhat.com/articles/2022/05/31/integrate-spring-boot-application-red-hat-data-grid"&gt;Integrate a Spring Boot application with Red Hat Data Grid&lt;/a&gt; and follow the instructions in &lt;a href="https://developers.redhat.com/articles/2022/05/31/integrate-spring-boot-application-red-hat-data-grid#gather_relevant_data_grid_cluster_data"&gt;Gather relevant Data Grid cluster data&lt;/a&gt; and &lt;a href="https://developers.redhat.com/articles/2022/05/31/integrate-spring-boot-application-red-hat-data-grid#how_to_deploy_the_spring_boot_project"&gt;How to deploy the Spring Boot project&lt;/a&gt;. The &lt;code&gt;application.properties&lt;/code&gt; file should look like the following:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;# context-path server.servlet.context-path=/redhat # allow all endoints exposure management.endpoints.web.exposure.include=* # Connection infinispan.remote.server-list=181.123.123.123:11222 infinispan.remote.client-intelligence=BASIC # Authentication infinispan.remote.use-auth=true infinispan.remote.sasl-mechanism=BASIC infinispan.remote.auth-realm=default infinispan.remote.auth-server-name=infinispan-test infinispan.remote.auth-username=developer infinispan.remote.auth-password=ygwaioo0XWhxMtBU infinispan.remote.sasl_properties.javax.security.sasl.qop=auth # Encryption infinispan.remote.sni_host_name=181.123.123.123 infinispan.remote.trust_store_file_name=/mnt/secrets/truststore.jks infinispan.remote.trust_store_password=password infinispan.remote.trust_store_type=jks # Marshalling infinispan.remote.marshaller=org.infinispan.commons.marshall.ProtoStreamMarshaller infinispan.remote.java-serial-allowlist=com.*,org.* infinispan.remote.java-serial-whitelist=com.*,org.* infinispan.client.hotrod.marshaller=org.infinispan.commons.marshall.ProtoStreamMarshaller infinispan.client.hotrod.java_serial_allowlist=com.*,org.* infinispan.client.hotrod.java_serial_whitelist=com.*,org.*&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Because we are using the LoadBalancer, the &lt;code&gt;infinispan.remote.server-list&lt;/code&gt; property has an assigned external IP address for the data grid service, exposed by OpenShift, instead of the SVC name rendered by DNS that appeared in the original version of the application. You can the IP address using the following command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ oc get svc |grep external infinispan-test-external LoadBalancer 10.20.21.22 181.123.123.123 11222:30890/TCP 22m &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Deploying the remote query application in OpenShift&lt;/h2&gt; &lt;p&gt;After updating the properties file, it's time to &lt;a href="https://developers.redhat.com/articles/2022/05/31/integrate-spring-boot-application-red-hat-data-grid#create_a_new_project_in_openshift_for_spring_boot_application_deployment"&gt;create a new OpenShift project&lt;/a&gt;. You can create it in the same OpenShift cluster where the Data Grid cluster is running or in a different remote cluster. A remote cluster can be used because you have external access to the Data Grid cluster via LoadBalancer:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ oc new-project springboot-test&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now, you can &lt;a href="https://developers.redhat.com/articles/2022/05/31/integrate-spring-boot-application-red-hat-data-grid#deploy_the_spring_boot_application"&gt;deploy the remote query application&lt;/a&gt;. Take care to run the following command from the application's new OpenShift project, which you can get into using the &lt;code&gt;oc project springboot-test&lt;/code&gt; command. Compile and deploy the application as follows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ mvn clean fabric8:deploy -Popenshift&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Finally, create a secret that will store the Keystore generated in the previous step:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ oc create secret generic truststore-secret --from-file=truststore.jks $ oc set volume dc/hotrodspringboot --add --name=truststore-secret -m /mnt/secrets/ -t secret --secret-name=truststore-secret --default-mode='0755'&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Testing the remote query&lt;/h2&gt; &lt;p&gt;Once you have deployed the application, you can test the remote query integration. You must get the exposed route for the service by using the &lt;code&gt;oc get routes&lt;/code&gt; command. Here is the output:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ oc get routes NAME HOST/PORT remote-query remote-query-springboot-test.openshiftcluster.com PATH SERVICES PORT TERMINATION WILDCARD remote-query 8080 None&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Send a request to the REST endpoint for the service using the &lt;code&gt;curl&lt;/code&gt; command:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ curl -X GET http://remote-query-springboot-test.openshiftcluster.com/redhat/query-cache/ - Book title 10 - 2022% &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Let's understand what happened when you invoked the&lt;code&gt;/query-cache&lt;/code&gt; service. First, as mentioned earlier, the Data Grid cluster imported the &lt;code&gt;book.proto&lt;/code&gt; structure to get the data structure needed to process the request from the remote query service. The &lt;code&gt;proto.book&lt;/code&gt; file was generated when you compiled the &lt;code&gt;RemoteQueryInitializer.java&lt;/code&gt; class. The &lt;code&gt;RemoteQuery.java&lt;/code&gt; constructor uploads the &lt;code&gt;proto.book&lt;/code&gt; file into the Data Grid cluster. The following code in the &lt;code&gt;RemoteQuery&lt;/code&gt; class puts that generated schema into the Data Grid cluster's cache data structure:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;public class RemoteQuery { ... @Autowired public RemoteQuery(RemoteCacheManager cacheManager) { ... GeneratedSchema schema = new RemoteQueryInitializerImpl(); metadataCache.put(schema.getProtoFileName(), schema.getProtoFile()); } ... }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Having the schema mapped on both sides, as shown in Figure 2, the service uploads a set of &lt;code&gt;Book&lt;/code&gt; objects into a Map and stores them in the Data Grid cache.&lt;/p&gt; &lt;p&gt;Data Grid executes the query and put the resultset into a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Book&lt;/code&gt; objects. This query gets all books that contain the characters '&lt;code&gt;10'&lt;/code&gt; in their titles:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; QueryFactory queryFactory = Search.getQueryFactory(remoteCache); Query&lt;Book&gt; query = queryFactory.create("FROM book_sample.Book WHERE title:'10'"); List&lt;Book&gt; list = query.execute().list();&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Our example performs both the data load into the cache and the query in the same &lt;code&gt;/query-cache&lt;/code&gt; service for the purpose of simplicity. However, each step could also be performed in different services, depending on the use case and application architecture.&lt;/p&gt; &lt;p&gt;There are also multiple ways to perform queries. The Ickle query syntax is explained in the &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html/querying_data_grid_caches/ickle-query-language#doc-wrapper"&gt;Data Grid documentation&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Adding indexes to Data Grid is easy and beneficial&lt;/h2&gt; &lt;p&gt;This article demonstrated how you can easily add Indexes to Data Grid. Indexed caches offer benefits such as:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Remote queries&lt;/li&gt; &lt;li&gt;Supports more complex data based on entities with multiple fields.&lt;/li&gt; &lt;li&gt;A broad range of query alternatives, shaped according to each use case.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;The official &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.3/html/querying_data_grid_caches/indexing-caches"&gt;product documentation&lt;/a&gt; contains details about indexing in Red Hat Data Grid. Please comment below if you have questions. We welcome your feedback.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/30/remotely-query-indexed-caches-data-grid-8" title="How to remotely query indexed caches in Data Grid 8"&gt;How to remotely query indexed caches in Data Grid 8&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Alexander Barbosa Ayala</dc:creator><dc:date>2022-11-30T07:00:00Z</dc:date></entry><entry><title type="html">A Maven starter for Jakarta EE projects</title><link rel="alternate" href="http://www.mastertheboss.com/java-ee/jakarta-ee/a-maven-starter-for-jakarta-ee-projects/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java-ee/jakarta-ee/a-maven-starter-for-jakarta-ee-projects/</id><updated>2022-11-29T13:05:15Z</updated><content type="html">This short article will teach you how to kickstart a simple Jakarta EE project using a Maven archetype that includes the basic building blocks for developing an application. The Jakarta Eclipse starter The Jakarta EE starter is available in two flavours: Next, let’s run the above command and check the outcome: The built-in application includes ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>How the new VSCode XML extension improves developer experience</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/29/new-vscode-xml-extension-improves-developer-experience" /><author><name>Mohit Suman, Angelo Zerr, Jessica He</name></author><id>881f18ea-6283-40bc-9066-213290e552e2</id><updated>2022-11-29T07:00:00Z</updated><published>2022-11-29T07:00:00Z</published><summary type="html">&lt;p&gt;At Red Hat, we look forward to creating and updating tools to improve the developer experience for users of various language servers. &lt;a href="https://code.visualstudio.com/docs"&gt;Visual Studio Code&lt;/a&gt; is one of the most popular tools for developers. The rich ecosystem of multiple extensions makes it more powerful.&lt;/p&gt; &lt;p&gt;We are excited to announce the release of &lt;a href="https://marketplace.visualstudio.com/items?itemName=redhat.vscode-xml"&gt;VSCode XML&lt;/a&gt; Extension 0.22.0 in Visual Studio Code Marketplace and OpenVSX Registry and the addition of more improvements and features to work with XML and improve the overall developer experience.&lt;/p&gt; &lt;h2&gt;A little VSCode XML history&lt;/h2&gt; &lt;p&gt;The VSCode team has continuously worked with the community and received user feedback and requests. It is interesting to see the evolution of the software based on these requests. The extension was originally created to manage pom.xml files of maven projects with the &lt;a href="https://marketplace.visualstudio.com/items?itemName=redhat.java"&gt;VSCode Java&lt;/a&gt; extension and provide XML and XSD support.&lt;/p&gt; &lt;p&gt;VSCode XML uses the LemMinx language server written in Java to provide the various language features. However, this required Java installation. Over time, we received more and more requests from users to use the extension without Java. That's why we provided the binary feature to run the language server without Java.&lt;/p&gt; &lt;p&gt;Because of multiple feature requests for RelaxNG support, we integrated &lt;a href="https://github.com/relaxng/jing-trang"&gt;Jing&lt;/a&gt; to implement RelaxNG support in the VSCode XML extension. This has been a great addition to the extension's feature list and has shown an upward trend in usage after the release.&lt;/p&gt; &lt;p&gt;Since then, we have made multiple improvements. In this blog, we will focus on two important features added to the current release.&lt;/p&gt; &lt;ol&gt;&lt;li&gt;&lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Features/RelaxNGFeatures.md"&gt;RelaxNG support&lt;/a&gt; provides completion, hover, and validation in XML files based on RelaxNG schemas.&lt;/li&gt; &lt;li&gt;We have made improvements to our &lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Formatting.md#xmlformatexperimental"&gt;experimental XML formatter&lt;/a&gt;.&lt;/li&gt; &lt;/ol&gt;&lt;h2&gt;1. RelaxNG Support&lt;/h2&gt; &lt;p&gt;&lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Features/RelaxNGFeatures.md"&gt;&lt;u&gt;RelaxNG support&lt;/u&gt;&lt;/a&gt; provides completion, hover, and validation in XML files based on RelaxNG schemas (&lt;a href="https://relaxng.org/tutorial-20011203.html"&gt;&lt;u&gt;XML syntax&lt;/u&gt;&lt;/a&gt; and &lt;a href="https://relaxng.org/compact-tutorial-20030326.html"&gt;&lt;u&gt;compact syntax&lt;/u&gt;&lt;/a&gt;). Figure 1 explains the workflow:&lt;/p&gt; &lt;figure role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/1.gif"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/1.gif" width="512" height="222" alt="An illustration of relax-ng-support." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1: The RelaxNG support workflow. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;Validation&lt;/h3&gt; &lt;p&gt;XML validation based on RelaxNG (&lt;code&gt;rng&lt;/code&gt; and &lt;code&gt;rnc&lt;/code&gt;) is supported as shown in Figure 2:&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/2_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/2_0.png?itok=afz8G3ic" width="512" height="233" alt="An illustration xml-validation process based on RelaxNG." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 2: The XML validation process based on RelaxNG. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;h3&gt;Completion&lt;/h3&gt; &lt;p&gt;It supports XML completion based on RelaxNG (&lt;code&gt;rng&lt;/code&gt;, &lt;code&gt;rnc&lt;/code&gt;). The completion for &lt;code&gt;rng&lt;/code&gt; displays the documentation in Figure 3:&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/3_3.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/3_3.png?itok=fvm3epaQ" width="512" height="215" alt="The xml-completion process based on RelaxNG." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 3: The XML completion process based on RelaxNG. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;h3&gt;Hover&lt;/h3&gt; &lt;p&gt;Hover based on RelaxNG &lt;code&gt;rng&lt;/code&gt; shows the documentation in Figure 4:&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/4_1.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/4_1.png?itok=rQqz3RF7" width="512" height="170" alt="An illustration of xml-hover based on RelaxNG." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 4: Hover based on RelaxNG. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;h3&gt;Go to type definition&lt;/h3&gt; &lt;p&gt;From the XML document, you can go to the type definition to navigate to the element/attribute declaration for &lt;code&gt;rnc&lt;/code&gt; and&lt;/p&gt; &lt;p&gt;To do this, select an XML element/attribute and use the contextual menu &lt;code&gt;Go to Type Definition&lt;/code&gt; as shown in Figure 5.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/5_2.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/5_2.png?itok=XktUjogE" width="512" height="246" alt="The XML Go To Type Definition action." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 5: The XML Go To Type Definition action. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;When you click on this menu item, VS Code will open the &lt;code&gt;rng&lt;/code&gt; or &lt;code&gt;rnc&lt;/code&gt; grammar file and place the cursor on the proper &lt;code&gt;element/attribute&lt;/code&gt; declaration as shown in Figure 6.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/6_0.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/6_0.png?itok=ZsjWimfH" width="512" height="260" alt="An illustration of the xml-grammar file support." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 6: The XML grammar file support. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;2. The experimental formatter&lt;/h2&gt; &lt;p&gt;The current XML formatter works correctly when XML is valid. For instance, given the following XML content:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;/foo&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The XML is formatted like this:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;foo&gt;   &lt;bar&gt;&lt;/bar&gt; &lt;/foo&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;But when XML content is invalid, as in the following example:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;&lt;foo&gt;&lt;bar'&lt;/bar&gt;&lt;/foo&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The XML is formatted like the following:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;foo&gt;   &lt;bar&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The formatter will lose all the invalid content, which can be extremely annoying. It is one reason we re-implemented a formatter from scratch with a new strategy. Here is the invalid content from above reformatted with the new experimental formatter:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;foo&gt; &lt;bar'&lt;/bar&gt;&lt;/foo&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To activate the experimental formatter, set &lt;strong&gt;“xml &gt; Format: Experimental”&lt;/strong&gt; to “&lt;strong&gt;true&lt;/strong&gt;” on the VS Code Settings Page or add the following to your settings.json:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-json"&gt;"xml.format.experimental": true&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This also opens the extension to the possibility of supporting XML with various embedded content within XML documents (eg. EJS).&lt;/p&gt; &lt;p&gt;Our goal is to make this new formatter the default once it supports all features of the current formatter. Please don’t hesitate to create &lt;a href="https://github.com/redhat-developer/vscode-xml/issues"&gt;any issues&lt;/a&gt; to improve the experimental formatter.&lt;/p&gt; &lt;h2&gt;How the new formatter works&lt;/h2&gt; &lt;p&gt;The current formatter gets the &lt;a href="https://www.w3.org/DOM/DOMTR"&gt;DOM document&lt;/a&gt;, the abstract representation of the XML document that &lt;code&gt;vscode-xml&lt;/code&gt; uses and rewrites the content of the document in one text edit:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-python"&gt;[     {         "range": {             "start": {                 "line": 0,                 "character": 0             },             "end": {                 "line": 0,                 "character": 22             }         },         "newText": "&lt;foo&gt;\r\n\t&lt;bar&gt;&lt;/bar&gt;\r\n&lt;/foo&gt;"     } ]&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The new experimental formatter preserves all non-whitespace content and inserts or removes spaces to correctly indent the XML content. In the following sample, two TextEdit are generated. The insert/replace characters avoid losing invalid content.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-python"&gt;[ { "range": { "start": { "line": 0, "character": 5 }, "end": { "line": 0, "character": 5 } }, "newText": "\r\n\t" }, { "range": { "start": { "line": 0, "character": 16 }, "end": { "line": 0, "character": 16 } }, "newText": "\r\n" } ] &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;New experimental formatted settings&lt;/h2&gt; &lt;p&gt;In addition to a list of default elements where whitespace will be preserved, users may choose to modify this with their own set of elements. Refer to the documentation &lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Formatting.md#xmlformatpreservespace"&gt;preserve space page&lt;/a&gt; for more information.&lt;/p&gt; &lt;p&gt;The following example shows two ways in which whitespaces will be preserved.&lt;/p&gt; &lt;p&gt;(Note: XML remains the same after formatting.)&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Method #1&lt;/strong&gt;: Figure 7 shows &lt;code&gt;literallayout&lt;/code&gt; in the list of default elements where whitespaces will be preserved.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/7-1.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/7-1.png?itok=MdoJv8Jk" width="473" height="234" alt="The xml-literal-layout tag support." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 7: The literallayout tag support. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;&lt;strong&gt;Method #2&lt;/strong&gt;: Figure 8 shows that any element with &lt;code&gt;xml:space = “preserve” &lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;will preserve whitespaces.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/7-2.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/7-2.png?itok=zXnvQQJR" width="452" height="235" alt="Preserve space support in XML." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 8: Preserve space support in XML. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;Support for the ability to set a maximum line width has been &lt;a href="https://github.com/redhat-developer/vscode-xml/issues/350"&gt;&lt;u&gt; requested and upvoted by many users&lt;/u&gt;&lt;/a&gt;. Currently, this setting works with text content and comments. We are on track to extend this feature to cover other use cases such as attributes and ensure its behavior is consistent when applied in combination with other settings. Refer to the documentation for &lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Formatting.md#xmlformatmaxlinewidth"&gt;maximum line width&lt;/a&gt; formatting.&lt;/p&gt; &lt;p&gt;The example in Figure 9 shows formatting with &lt;code&gt;maxLineWidth&lt;/code&gt; set to the default value of 80.&lt;/p&gt; &lt;figure class="align-center" role="group"&gt;&lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/8.gif"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/8.gif" width="512" height="162" alt="The XML max line width support." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 9: The XML max line width support. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt; &lt;/p&gt; &lt;p&gt;There are a growing number of use cases supported with this setting. This option enables the formatter to consider &lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Formatting.md#xmlformatgrammarawareformatting"&gt;XML Schema/DTD grammar information&lt;/a&gt; when making decisions. For instance, an element defined as “&lt;code&gt;xs:string&lt;/code&gt;” in the schema will preserve any whitespace in the content when formatting.&lt;/p&gt; &lt;p&gt;For more information on the specific use cases, visit the official VSCode XML &lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/docs/Formatting.md#xmlformatgrammarawareformatting"&gt;GitHub page&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Contribute and get support&lt;/h2&gt; &lt;p&gt;This is an open-source project available to anyone. Contributions are extremely welcome! To get started, refer to the &lt;a href="https://github.com/redhat-developer/vscode-xml/blob/main/CONTRIBUTING.md"&gt;contributing instructions&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;If you encounter any bugs, confusing commands, or unclear documentation, or if you would like to propose a feature request, you can:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;File a bug in &lt;a href="https://github.com/redhat-developer/vscode-xml/issues"&gt;GitHub Issues&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Chat with us on &lt;a href="https://gitter.im/redhat-developer/vscode-xml"&gt;Gitter&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Review documentation on &lt;a href="https://github.com/redhat-developer/vscode-xml/tree/main/docs"&gt;GitHub&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;Refer to the &lt;a href="https://github.com/redhat-developer/vscode-xml/releases/tag/0.22.0"&gt;Release Notes&lt;/a&gt;.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;We are actively working to improve the developer experience with XML. Stay tuned for more features coming soon!&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/29/new-vscode-xml-extension-improves-developer-experience" title="How the new VSCode XML extension improves developer experience"&gt;How the new VSCode XML extension improves developer experience&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Mohit Suman, Angelo Zerr, Jessica He</dc:creator><dc:date>2022-11-29T07:00:00Z</dc:date></entry><entry><title type="html">Drools Reactive Messaging processing</title><link rel="alternate" href="https://blog.kie.org/2022/11/drools-reactive-messaging-processing.html" /><author><name>Toshiya Kobayashi</name></author><id>https://blog.kie.org/2022/11/drools-reactive-messaging-processing.html</id><updated>2022-11-29T03:15:33Z</updated><content type="html">The latest Drools 8.31.0.Final comes with a Reactive Messaging example, which demonstrates reactively consuming messages from a Kafka topic, firing rules and then sending result messages to another Kafka topic. You can find it in . This blog post explains how it works. HOW TO RUN THE EXAMPLE Clone drools repository $ git clone https://github.com/kiegroup/drools.git Go to the example directory $ cd drools-drl-quarkus-extension/drools-drl-quarkus-examples/drools-drl-quarkus-examples-reactive/ docker-compose.yml is provided for a quick test with Kafka and Kafdrop. $ docker-compose up -d Build and start the application with dev mode. $ mvn clean compile quarkus:dev Open another terminal and send a message to a Kafka topic events $ echo '{"type":"temperature","value":35}' | kafka-console-producer.sh --broker-list localhost:9092 --topic events You will see STDOUT log in the terminal where the application is running. It means the message is consumed and the rule is fired. rule IncomingEvent fired : Event [type=temperature, value=35] If you access Kafdrop with a browser, which is already started by docker-compose, you will find alerts topic. You can confirm the result message sent by the rule. {"severity":"warning","message":"Event [type=temperature, value=35]"} To shutdown the app, press Ctrl+C on the terminal. To shutdown Kafka and Kafdrop, $ docker-compose down HOW IT WORKS Here is the diagram of this example architecture. The important part is how to connect Drools DataSources with Kafka topics. Thanks to Quarkus’ reactive messaging support, we can achieve it with a very small amount of codes. In order to get reactive messaging support with Kafka, you just need to have a dependency quarkus-smallrye-reactive-messaging-kafka. &lt;dependency&gt; &lt;groupId&gt;io.quarkus&lt;/groupId&gt; &lt;artifactId&gt;quarkus-smallrye-reactive-messaging-kafka&lt;/artifactId&gt; &lt;/dependency&gt; Take a look at Adaptor class. @Startup @ApplicationScoped public class Adaptor { @Inject RuleUnit&lt;AlertingUnit&gt; ruleUnit; AlertingUnit alertingUnit; RuleUnitInstance&lt;AlertingUnit&gt; ruleUnitInstance; @Inject @Channel("alerts") Emitter&lt;Alert&gt; emitter; @PostConstruct void init() { this.alertingUnit = new AlertingUnit(); this.ruleUnitInstance = ruleUnit.createInstance(alertingUnit); alertingUnit.getAlertData().subscribe(DataObserver.of(emitter::send)); } @Incoming("events") public void receive(Event event) throws InterruptedException { alertingUnit.getEventData().append(event); ruleUnitInstance.fire(); } } With @Incoming("events"), you can receive Event object from Kafka topic events. This association is configured in application.properties. mp.messaging.incoming.events.connector=smallrye-kafka mp.messaging.incoming.events.topic=events mp.messaging.incoming.events.value.deserializer=org.drools.quarkus.ruleunit.examples.reactive.EventDeserializer mp.messaging.outgoing.alerts.connector=smallrye-kafka mp.messaging.outgoing.alerts.topic=alerts mp.messaging.outgoing.alerts.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer When "IncomingEvent" rule is fired, an Alert object is appended to DataStream alertData. rule IncomingEvent when $e : /eventData [ type == "temperature", value &gt;= 30 ] then System.out.println("rule IncomingEvent fired : "+ $e); Alert alert = new Alert( "warning", $e.toString() ); alertData.append( alert ); end As you see in Adaptor.init(), the Alert object will be sent to Kafka topic alerts. Now you can develop a rule service which consumes messages reactively in a micro service environment. GOING FORWARD We plan to develop Specialized DataSources to connect out-of-the-box Drools rule units with external frameworks and tools, e.g. reads/writes from a Kafka topic even without a glue code like the Adaptor class. Stay tuned! The post appeared first on .</content><dc:creator>Toshiya Kobayashi</dc:creator></entry><entry><title type="html">Quarkus support for AWS Lambda SnapStart</title><link rel="alternate" href="https://quarkus.io/blog/quarkus-support-for-aws-lambda-snapstart/" /><author><name>Shaaf</name></author><id>https://quarkus.io/blog/quarkus-support-for-aws-lambda-snapstart/</id><updated>2022-11-28T00:00:00Z</updated><content type="html">Quarkus support for AWS Lambda SnapStart Amazon Web Services (AWS) announced the SnapStart feature for AWS Lambda. SnapStart for Java reduces startup latency for Java-based functions running on AWS Lambda, and Quarkus supports it from day one! Quarkus is supersonic subatomic Java with a focus on cloud-native applications. The idea...</content><dc:creator>Shaaf</dc:creator></entry><entry><title>.NET, Go, Kamelets, and more: Top articles from November 2022</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/24/net-go-kamelets-and-more-top-articles-november-2022" /><author><name>Heiker Medina</name></author><id>8a3c16cc-51fd-42d2-bf3d-741065b76de7</id><updated>2022-11-24T07:00:00Z</updated><published>2022-11-24T07:00:00Z</published><summary type="html">&lt;p&gt;Whether you'll soon be signing off for a fall November break or working through the end of the month, take a moment to check out Red Hat Developer's latest top-performing articles. We've highlighted the tutorial guides and announcements that our developer community has engaged with the most.&lt;/p&gt; &lt;h2&gt;Announcements&lt;/h2&gt; &lt;ul&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/08/net-7-now-available-rhel-and-openshift"&gt;.NET 7 now available for RHEL and OpenShift&lt;/a&gt;:&lt;/strong&gt; This short overview from John Clingan discusses what you need to know about &lt;a href="https://developers.redhat.com/topics/dotnet"&gt;.NET&lt;/a&gt; 7. The .NET 7 release is now available, targeting &lt;a href="https://developers.redhat.com/products/rhel/overview"&gt;Red Hat Enterprise Linux&lt;/a&gt; (RHEL) 8.7, RHEL 9.1, and &lt;a href="https://developers.redhat.com/products/openshift/overview"&gt;Red Hat OpenShift&lt;/a&gt;.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/04/intros-deep-dives-and-announcements-our-best-october-2022"&gt;Intros, deep dives, and announcements: Our best of October 2022&lt;/a&gt;:&lt;/strong&gt; Here are some highlights from Red Hat Developer for October 2022, organized by product announcements, topic roundups, learning guides, and advanced deep dives&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;Tutorials&lt;/h2&gt; &lt;ul&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/14/3-ways-embed-commit-hash-go-programs"&gt;3 ways to embed a commit hash in Go programs&lt;/a&gt;:&lt;/strong&gt; When you need to view the source code of an older version of your software, it is handy to have the history feature turned on. Panagiotis Georgiadis's guide explains how to see what your &lt;a href="https://developers.redhat.com/topics/go"&gt;Go&lt;/a&gt; program looked like at various points in time, so you can debug issues that may have been introduced at specific points.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/09/how-static-application-security-testing-improves-software-security"&gt;How static application security testing improves software security&lt;/a&gt;:&lt;/strong&gt; Join Florencio Cano Gabarda as he explains why static application security testing (SAST) is an effective tool for improving the security of your application. Developers can use SAST to identify potential security problems in the source code for an application, its bytecode, or its binary code. Many SAST tools are mature and widely used by software developers.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/08/introduction-debug-events-learn-how-use-breakpoints"&gt;An introduction to debug events: Learn how to use breakpoints&lt;/a&gt;:&lt;/strong&gt; This article kicks off a series about GDB's debugging capabilities. Keith Seitz will be covering the commands, convenience variables, and functions that will aid you in stopping GDB at the right place at the right time.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/01/how-kamelets-simplify-camel-integrations-kubernetes"&gt;How Kamelets simplify Camel integrations on Kubernetes&lt;/a&gt;:&lt;/strong&gt; Modern applications are often made of a collection of several smaller applications, or subsystems. This article explains how Apache Camel and &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt; make it easy to integrate such services through Kamelets.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/07/build-reactive-apps-kubernetes-using-camel-k"&gt;Build reactive apps on Kubernetes using Camel K&lt;/a&gt;:&lt;/strong&gt; In this article, Sumit Mukherjee will explain how &lt;a href="https://developers.redhat.com/topics/camel-k"&gt;Apache Camel K&lt;/a&gt; can make it easier to develop reactive applications on Kubernetes by integrating data sources, &lt;a href="https://developers.redhat.com/topics/kafka-kubernetes"&gt;Apache Kafka&lt;/a&gt; brokers, and Knative for event management.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/03/nodejs-reference-architecture-part-10-accessibility"&gt;Node.js Reference Architecture, Part 10: Accessibility&lt;/a&gt;:&lt;/strong&gt; Michael Dawson guides you through the importance of integrating accessibility within your &lt;a href="https://developers.redhat.com/topics/nodejs"&gt;Node.js&lt;/a&gt; applications. Making your applications accessible to disabled users is good business and often required by law. As a Node.js developer, you need to understand the issues around accessibility so that you can build truly accessible components into the applications you build.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/10/set-openshift-cluster-deploy-application-odo-cli"&gt;Set up an OpenShift cluster to deploy an application in odo CLI&lt;/a&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/10/implement-restapi-application-mongodb-using-sbo"&gt;Implement a Rest API application with MongoDB using SBO&lt;/a&gt;:&lt;/strong&gt; In this two-part series, Francesco Ilario shows you how to use &lt;code&gt;odo&lt;/code&gt; to create an application and a database service, bind the application to the database using the Service Binding Operator, and get access to the application's REST API. You'll deploy a REST API application and bind it to a MongoDB using &lt;code&gt;odo&lt;/code&gt; and the Service Binding Operator. The series shows you how easy it is to create an instance of a database and a binding (connection) between the application and that database.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;November 2022 on Red Hat Developer&lt;/h2&gt; &lt;p&gt;Here's the full lineup of articles published on Red Hat Developer this month:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/21/why-gpus-are-essential-computing"&gt;Why GPUs are essential for AI and high-performance computing&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/18/modernize-scale-new-migration-toolkit-applications"&gt;Modernize at scale with the new migration toolkit for applications&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/17/new-features-openmp-51-and-openmp-52"&gt;New features in OpenMP 5.1 and OpenMP 5.2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/17/benchmarking-improved-conntrack-performance-ovs-300"&gt;Benchmarking improved conntrack performance in OvS 3.0.0&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/16/whats-new-red-hat-enterprise-linux-91"&gt;What's new in Red Hat Enterprise Linux 9.1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/16/openshift-essential-containerized-applications"&gt;Why OpenShift is essential for containerized applications&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/15/knative-broker-enhances-kafka-openshift-serverless"&gt;How Knative broker GA enhances Kafka on OpenShift Serverless&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/15/how-categorize-c-programs-behavior"&gt;How to categorize C programs by behavior&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/14/3-ways-embed-commit-hash-go-programs"&gt;3 ways to embed a commit hash in Go programs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/10/implement-restapi-application-mongodb-using-sbo"&gt;Implement a Rest API application with MongoDB using SBO&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/10/set-openshift-cluster-deploy-application-odo-cli"&gt;Set up an OpenShift cluster to deploy an application in odo CLI&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/09/how-static-application-security-testing-improves-software-security"&gt;How static application security testing improves software security&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/08/net-7-now-available-rhel-and-openshift"&gt;.NET 7 now available for RHEL and OpenShift&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/08/visual-guide-deploying-jboss-eap-aws"&gt;A visual guide to deploying JBoss EAP on AWS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/08/introduction-debug-events-learn-how-use-breakpoints"&gt;An introduction to debug events: Learn how to use breakpoints&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/07/build-reactive-apps-kubernetes-using-camel-k"&gt;Build reactive apps on Kubernetes using Camel K&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/03/nodejs-reference-architecture-part-10-accessibility"&gt;Node.js Reference Architecture, Part 10: Accessibility&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/03/how-next-10-project-supports-future-nodejs"&gt;How the Next-10 project supports the future of Node.js&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/11/01/how-kamelets-simplify-camel-integrations-kubernetes"&gt;How Kamelets simplify Camel integrations on Kubernetes&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://developers.redhat.com/articles/2022/10/31/best-practices-application-shutdown-openssl"&gt;Best practices for application shutdown with OpenSSL&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/24/net-go-kamelets-and-more-top-articles-november-2022" title=".NET, Go, Kamelets, and more: Top articles from November 2022"&gt;.NET, Go, Kamelets, and more: Top articles from November 2022&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Heiker Medina</dc:creator><dc:date>2022-11-24T07:00:00Z</dc:date></entry><entry><title type="html">Reactive CRUD Performance: A Case Study</title><link rel="alternate" href="https://quarkus.io/blog/reactive-crud-performance-case-study/" /><author><name>John O'Hara</name></author><id>https://quarkus.io/blog/reactive-crud-performance-case-study/</id><updated>2022-11-23T23:00:00Z</updated><content type="html">We were approached for comment about the relative performance of Quarkus for a reactive CRUD workload. This is a good case study into performance test design and some of the considerations required and hurdles that need to be overcome. What methodology can we derive for ensuring that the test we...</content><dc:creator>John O'Hara</dc:creator></entry><entry><title type="html">Kogito Serverless Workflow event formats</title><link rel="alternate" href="https://blog.kie.org/2022/11/kogito-serverless-workflow-event-formats.html" /><author><name>Francisco Javier Tirado Sarti</name></author><id>https://blog.kie.org/2022/11/kogito-serverless-workflow-event-formats.html</id><updated>2022-11-23T18:56:28Z</updated><content type="html">The relies on for event publishing and consumption. CloudEvents are designed in a way that might work with any event format. That goal is achieved by declaring the data property, the one containing the event information, as an array of bytes.  expects that incoming and outgoing events represent a CloudEvent and that its data property content is convertible to a JSON object. The process of converting the CloudEvent to an object that can be understood by an external event broker is called marshaling. The inverse procedure, the one that converts the external event broker object into a CloudEvent is called unmarshaling. They are usually, but not always, coupled and I will refer to both of them as (un)marshal procedure for brevity.  When Kogito is running on the Quarkus platform, integration with external event brokers is performed through, as described in this .  The main abstraction provided by a Smallrye connector is the channel. By default, Kogito assumes that all channels within a Workflow application use the same logic for marshaling and unmarshaling. However, in complex applications, the event format used by a channel might be different from the one used by other channels within the same application, therefore Kogito provides means to specify which (un)marshal procedure should be used for each channel.  This post describes (un)marshal procedures provided by Kogito Serverless Workflow out of the box and focuses on how to set up a workflow application to use them, either globally or channel specific. It also discusses how to add new (un)marshal procedures to Kogito Serverless Workflows programmatically, if the included ones are not suitable. The only thing you will need is basic Java knowledge and some familiarity with J2EE CDI functionality, specifically the annotation.  APPLICATION (UN)MARSHALER As mentioned previously, if nothing is configured, Kogito Serverless workflow assumes all channels within the same application utilize the same (un)marshall procedure, based on library. This means that Jackson parser should be able to convert the Smallrye message payload into a JSON object without errors and vice versa.  Let’s assume you want your application to use a different event format. We are going to describe how to do that for , taking advantage of the fact that Kogito Serverless provides out of the box an (un)marshaler based on the CloudEvent specification . However, you should be aware that the same procedure can be used to configure  any  other (un)marshaler.  There are the steps you need to follow: 1. Add kogito-marshallers-avro dependency to your pom.xml &lt;dependency&gt;   &lt;groupId&gt;org.kie.kogito&lt;/groupId&gt;   &lt;artifactId&gt;kogito-addons-quarkus-marshallers-avro&lt;/artifactId&gt; &lt;/dependency&gt; 2. Define, under /src/main/java, a bean factory class that creates the desired bean definitions for and interfaces. In the class below, we are using the implementations provided by Kogito marshaller addon included as dependency in the previous step.  @ApplicationScoped public class ApplicationMarshallerProducer {     private AvroIO avroIO;     @PostConstruct     void init() throws IOException {             avroIO = new AvroIO();     }     @Produces     public CloudEventUnmarshallerFactory&lt;byte[]&gt; getAvroCloudEventUnmarshallerFactory() {             return new AvroCloudEventUnmarshallerFactory(avroIO);     }     @Produces     public CloudEventMarshaller&lt;byte[]&gt; getAvroCloudEventMarshaller() {               return new AvroCloudEventMarshaller(avroIO);     } } The previous setup assumes that all messages have as payload an array of bytes. When using Kafka, this is achieved by using the proper serializer and deserializer. In order to do that, you should  set these properties for every channel: mp.messaging.outgoing.&lt;channelName&gt;.value.deserializer=org.apache.kafka.common.serialization.ByteArrayDeserializer mp.messaging.outgoing.&lt;channelName&gt;.value.serializer=org.apache.kafka.common.serialization.ByteArraySerializer You might be wondering why you need to add a Java class to set up the global marshaller. This is intentional to allow flexibility. For example, you might want your application consumes Avro event format and republish them in Json event format. To do that, you just need to set up the marshaller to be the Jackson one and unmarshaller to be the Avro one, using a Java class as below.  @ApplicationScoped public class ApplicationMarshallerProducer {         @Inject     ObjectMapper objectMapper;     private AvroIO avroIO;        @PostConstruct     void init() throws IOException {             avroIO = new AvroIO();     }     @Produces     public CloudEventUnmarshallerFactory&lt;byte[]&gt; getAvroCloudEventUnmarshallerFactory() {             return new AvroCloudEventUnmarshallerFactory(avroIO);     }     @Produces     public CloudEventMarshaller&lt;byte[]&gt; getJacksonCloudEventMarshaller()      {               return new ByteArrayEventMarshaller(objectMapper);     } } PER CHANNEL (UN)MARSHALER You have learned how to set up the application level (un)marshaler procedure, but what happens if your application defines several incoming channels, one of them is expecting events to arrive in avro format, and the other one expects json format? The answer is pretty easy, since the default (un)marshaller procedure is based on Jackson, you just need to configure the channel that consumes Avro events to use the Avro unmarshaller.  In order to do that, you need to perform the following steps: 1. Add kogito-marshallers-avro dependency to your pom.xml &lt;dependency&gt;   &lt;groupId&gt;org.kie.kogito&lt;/groupId&gt;   &lt;artifactId&gt;kogito-addons-quarkus-marshallers-avro&lt;/artifactId&gt; &lt;/dependency&gt; 2. Define a named bean for the CloudEventUnmarshallerFactory interface, annotated with ChannelFormat annotation. In the class below,  the bean name is “avro” and the implementation is the one provided by the Kogito marshaller addon.  @ApplicationScoped public class AvroMarshallerProducer {     private AvroIO avroIO;     @PostConstruct     void init() throws IOException {         avroIO = new AvroIO();     }     @Produces     @Named(“avro”)     @ChannelFormat     public CloudEventUnmarshallerFactory&lt;byte[]&gt; getAvroCloudEventUnmarshallerFactory() {         return new AvroCloudEventUnmarshallerFactory(avroIO);     } } 3. Add a property that establishes the mapping between the channel and the bean name. The property formats are: *  kogito.addon.messaging.unmarshaller.&lt;channelName&gt;=&lt;beanName&gt; for incoming  channels. *  kogito.addon.messaging.marshaller.&lt;channelName&gt;=&lt;beanName&gt; for outgoing channels. Notice that you can map several channels to the same bean. For example, if the channel name is applicants, since your channel is incoming, you need to add this line to application.properties kogito.addon.messaging.unmarshaller.applicants=avro If your application had two incoming channels using avro, you would need to add: kogito.addon.messaging.unmarshaller.newApplicants=avro kogito.addon.messaging.unmarshaller.legacyAppicant=avro You can  find a serverless workflow application using Avro and Json for incoming channels in the Kogito examples .  ADDING CUSTOM MARSHALLERS You already know how to set up application and channel level (un)marshaller procedures using predefined Kogito ones: Jackson and Avro, but what happens if your channels use a different format? In that case, you need to provide your own implementation of the (un)marshaller procedure.  You probably are already aware that setting up a custom (un)marshaller procedure is equivalent to using a predefined one. The difference is that rather than including an existing Kogito addon as dependency in your pom and utilize the classes defined there to produce the required CDI beans, you need to develop your own classes and use them as CDI beans instead. Therefore this section explains which Kogito interfaces need to be implemented to do so. It is assumed that you are fluent in Java.  There are three interfaces to implement, CloudEventMarshaller, and CloudEventUnmarshallerFactory. You can use the as a reference to follow the explanation in the paragraphs below.  UNMARSHALLER IMPLEMENTATION CloudEventUnmarshallerFactory is responsible for creating CloudEventUnmarshaller instances suitable for the provided class parameter, which in the case of Serverless Workflow is always (remember that Kogito is intended to work also with BPMN, which uses ) Therefore, let’s focus on CloudEventUnmarshaller, which is responsible for converting the message payload into a CloudEvent and its data property into a JsonNode.  public interface CloudEventUnmarshaller&lt;I, O&gt; {     /**     * Create Cloud Event from structure event payload     *     * @return Cloud Event     */     Converter&lt;I, CloudEvent&gt; cloudEvent();     /**     * Create Cloud Event from binary event payload     *     * @return Cloud Event Data     */     Converter&lt;I, CloudEventData&gt; binaryCloudEvent();     /**     * Creates Kogito business object from Cloud Event data     *     * @return Kogito Businnes Object     */     Converter&lt;CloudEventData, O&gt; data(); } Let’s start first with the generic type I, which represents the possible message payloads. Currently, there are three of them: String, byte[] and Object. Note that Avro (un)marshaller procedure assumes that it is a byte[]. Generic type O is the target object type, which, as mentioned, is always JsonNode for Serverless Workflow.  Finally, there is the interface, which is a checked version of . This interface is responsible for converting from source type to target type and throws an if there is any conversion issue. An unmarshaller implementation should provide three converters: 1. cloudEvent method converter is used when the CloudEvent is delivered as   2. binaryCloudEvent method converter is used when the CloudEvent is delivered as .  3. data method converter is used regardless of the mode message to convert CloudEventData into the target object type.  MARSHALLER IMPLEMENTATION  CloudEventMarshaller interface is responsible for transforming the CloudEvent into a message payload. Note that Kogito assumes structure mode for publishing.  public interface CloudEventMarshaller&lt;R&gt; {     /**     * Convert cloud event into the type expected by the external service     *     * @param event Cloud event to be converted     * @return object to be sent to the external service     * @throws IOException if there is a conversion problem. This method must NOT report event formatting issues through a runtime exception, it must use IOException. This way the caller     *         can differentiate between unexpected issues and event formatting ones.     */     R marshall(CloudEvent event) throws IOException;     /**     * Convert Kogito business object into a CloudEventData for marshaling     *     * @param &lt;T&gt; the Kogito business object type     * @return A CloudEventData that will be marshaled.     */     &lt;T&gt; Function&lt;T, CloudEventData&gt; cloudEventDataFactory(); } GenericType R represents the target message payload type. Possible types are byte[], String and Object.  There are two methods to implement:  1. Marshall methods convert the CloudEvent into the target message payload.  2. cloudEventDataFactory is used internally by Kogito when a CloudEvent is built, for publishing  purposes, to fill its data property. It  converts the Kogito business object (JsonNode in the case of a Serverless Workflow), represented by generic type T, into a CloudEventData instance. This method belongs to the marshaller interface because the CloudEventData implementation to be part of the CloudEvent usually depends on the marshaling procedure.  The post appeared first on .</content><dc:creator>Francisco Javier Tirado Sarti</dc:creator></entry><entry><title>How to deploy Next.js applications to Red Hat OpenShift</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/11/23/how-deploy-nextjs-applications-red-hat-openshift" /><author><name>Michael Dawson</name></author><id>eeff6449-d837-4fc1-bc79-4a7a8fdd9434</id><updated>2022-11-23T07:00:00Z</updated><published>2022-11-23T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://nextjs.org/"&gt;Next.js&lt;/a&gt; is a popular &lt;em&gt;framework&lt;/em&gt; for deploying sites based on &lt;a href="https://nodejs.org/en/"&gt;Node.js&lt;/a&gt;. You can read about many popular Node.js frameworks in &lt;a href="https://developers.redhat.com/articles/2021/12/03/introduction-nodejs-reference-architecture-part-6-choosing-web-frameworks"&gt;part 6&lt;/a&gt; of the Red Hat Developer series on the &lt;a href="https://developers.redhat.com/blog/2021/03/08/introduction-to-the-node-js-reference-architecture-part-1-overview"&gt;Node.js reference architecture&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;In this article, you'll learn how to deploy Next.js applications using the &lt;a href="https://catalog.redhat.com/software/containers/ubi8/nodejs-16/615aee9fc739c0a4123a87e1"&gt;ubi8/nodejs-16&lt;/a&gt; and &lt;a href="https://catalog.redhat.com/software/containers/ubi8/nodejs-16-minimal/615aefd53f6014fa45ae1ae2"&gt;ubi8/nodejs-16-minimal&lt;/a&gt; containers available from Red Hat.&lt;/p&gt; &lt;p&gt;If you are a Red Hat customer with support, then you'll want to use the UBI or RHEL containers; this article was inspired in part because one of our customers asked us how to do that with Next.js. Even if you are not a customer yet, ubi8 containers are free to use and a great choice; we've seen their usage continue to grow.&lt;/p&gt; &lt;p&gt;Once you've seen how to build a Next.js application on top of the UBI containers, we'll show you how you can do the build and run on the &lt;a href="https://developers.redhat.com/products/openshift/getting-started"&gt;Red Hat OpenShift&lt;/a&gt; Container Platform, which is a great way to deploy your applications in a hybrid cloud environment.&lt;/p&gt; &lt;h2&gt;Using Next.js with or without Node.js?&lt;/h2&gt; &lt;p&gt;Like a number of other frameworks, Next.js can export your application as &lt;a href="https://nextjs.org/docs/advanced-features/static-html-export"&gt;static HTML&lt;/a&gt;. However, only a subset of features are supported, with serverless functions and server-side rendering being two major features you wouldn't be able to use. If you are deploying as static HTML only, you most likely want to use Nginx to serve that static HTML. The Red Hat Developer article &lt;a href="https://developers.redhat.com/blog/2018/10/23/modern-web-applications-on-openshift-part-2-using-chained-builds#"&gt;Modern web applications on OpenShift: Using chained builds&lt;/a&gt; shows you how you can do that with Nginx and OpenShift.&lt;/p&gt; &lt;p&gt;In this article, though, we'll assume you do want to use features like serverless functions and server-side rendering. That means you need Node.js to run your Next.js application in production.&lt;/p&gt; &lt;h2&gt;Building a container to run your Next.js application&lt;/h2&gt; &lt;p&gt;While the stewards of Next.js would like you to run in their environment, there are reasons you might not want to do so. Some organizations want more control over their deployments and either prefer to host them on their own infrastructure or with a cloud provider of their choice.&lt;/p&gt; &lt;p&gt;The good news is that there is some information on building containers to host a Next.js application in the &lt;a href="https://github.com/vercel/next.js/tree/canary/examples/with-docker"&gt;examples&lt;/a&gt; that Next.js provides. We can use that pattern and adapt it to use the ubi8 Node.js containers using a &lt;em&gt;multi-stage build.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;A multi-stage build is a best practice that uses a larger builder image during the build and a smaller deployment image for the final container. This works because not all components that are needed during the build are required for deployment. For example, a C++ compiler that may be needed to build a native add-on would not ultimately be needed when you deploy the application. The result is that the end container can be much smaller than it would be if the build container were used for the final image. You can read more about this &lt;a href="https://github.com/nodeshift/nodejs-reference-architecture/blob/main/docs/development/building-good-containers.md#use-multi-stage-builds"&gt;here&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;In order to build the Next.js application into a container, we need the applications files, a Dockerfile, and a Next.js configuration file that tells Next.js to build for a stand-alone deployment. Here's what the Next.js configuration file, called &lt;code&gt;next.config.js&lt;/code&gt;, should look like:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;/** @type {import('next').NextConfig} */ module.exports = { output: 'standalone', }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The Dockerfile is as shown below. We will explain each section after the listing.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;# adapted from https://github.com/vercel/next.js/tree/canary/examples/with-docker # needs next.config.js to set build to stand-alone with context as follows # /** @type {import('next').NextConfig} */ # module.exports = { # output: 'standalone', # } # Recommended to have .dockerignore file with the following content # Dockerfile # .dockerignore # node_modules # npm-debug.log # README.md # .next # .git # Install dependencies only when needed FROM registry.access.redhat.com/ubi8/nodejs-16 AS deps USER 0 WORKDIR /app # Install dependencies based on the preferred package manager COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./ RUN \ if [ -f yarn.lock ]; then yarn --frozen-lockfile; \ elif [ -f package-lock.json ]; then npm ci; \ elif [ -f pnpm-lock.yaml ]; then yarn global add pnpm &amp;&amp; pnpm i; \ else echo "Lockfile not found." &amp;&amp; exit 1; \ fi # Rebuild the source code only when needed FROM registry.access.redhat.com/ubi8/nodejs-16 AS builder USER 0 WORKDIR /app COPY --from=deps /app/node_modules ./node_modules COPY . . # Next.js collects completely anonymous telemetry data about general usage. # Learn more here: https://nextjs.org/telemetry # Uncomment the following line in case you want to disable telemetry during the build. ENV NEXT_TELEMETRY_DISABLED 1 # If using yarn uncomment out and comment out npm below # RUN yarn build # If using npm comment out above and use below instead RUN npm run build # Production image, copy all the files and run next FROM registry.access.redhat.com/ubi8/nodejs-16-minimal AS runner USER 0 WORKDIR /app ENV NODE_ENV production # Uncomment the following line in case you want to enable telemetry during runtime. ENV NEXT_TELEMETRY_DISABLED 1 COPY --from=builder /app/public ./public # Automatically leverage output traces to reduce image size # https://nextjs.org/docs/advanced-features/output-file-tracing COPY --from=builder --chown=1001:1001 /app/.next/standalone ./ COPY --from=builder --chown=1001:1001 /app/.next/static ./.next/static USER 1001 EXPOSE 3000 ENV PORT 3000 CMD ["node", "server.js"]&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The Dockerfile builds two intermediate layers (&lt;code&gt;deps&lt;/code&gt; and &lt;code&gt;builder&lt;/code&gt;) and then the final image that we will deploy.&lt;/p&gt; &lt;p&gt;The first section installs the dependencies in the &lt;code&gt;deps&lt;/code&gt; layer. The &lt;code&gt;FROM&lt;/code&gt; line indicates that ubi8/nodejs-16 should be used as the base image for the layer.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;# Install dependencies only when needed FROM registry.access.redhat.com/ubi8/nodejs-16 AS deps USER 0 WORKDIR /app # Install dependencies based on the preferred package manager COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./ RUN \ if [ -f yarn.lock ]; then yarn --frozen-lockfile; \ elif [ -f package-lock.json ]; then npm ci; \ elif [ -f pnpm-lock.yaml ]; then yarn global add pnpm &amp;&amp; pnpm i; \ else echo "Lockfile not found." &amp;&amp; exit 1; \ fi &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The second part copies over the dependencies and then builds the application as a builder layer. Again, we use ubi8/nodejs-16 as the base image. We've also chosen to disable telemetry and to build with &lt;code&gt;npm&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;​​​​​​​# Rebuild the source code only when needed FROM registry.access.redhat.com/ubi8/nodejs-16 AS builder USER 0 WORKDIR /app COPY --from=deps /app/node_modules ./node_modules COPY . . # Next.js collects completely anonymous telemetry data about general usage. # Learn more here: https://nextjs.org/telemetry # Uncomment the following line in case you want to enable telemetry during the build. ENV NEXT_TELEMETRY_DISABLED 1 # If using yarn uncomment out and comment out npm below # RUN yarn build # If using npm comment out above and use below instead RUN npm run build&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In the final step, we use the ubi8/nodejs-16-minimal image, as we don't need the tools and packages required for the build. Then we copy over the components that were built to create the final minimal image that will run the application.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;# Production image, copy all the files and run next FROM registry.access.redhat.com/ubi8/nodejs-16-minimal AS runner USER 0 WORKDIR /app ENV NODE_ENV production # Uncomment the following line in case you want to enable telemetry during runtime. ENV NEXT_TELEMETRY_DISABLED 1 COPY --from=builder /app/public ./public # Automatically leverage output traces to reduce image size # https://nextjs.org/docs/advanced-features/output-file-tracing COPY --from=builder --chown=1001:1001 /app/.next/standalone ./ COPY --from=builder --chown=1001:1001 /app/.next/static ./.next/static USER 1001 EXPOSE 3000 ENV PORT 3000 CMD ["node", "server.js"]&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In each of these steps, we set the user to 0 with &lt;code&gt;USER 0&lt;/code&gt; at the start so that we can copy to the desired locations. This is necessary because the UBI Node.js images have the user set to 1001 by default for usage with &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_software_collections/2/html/using_red_hat_software_collections_container_images/sti"&gt;Source-to-Image&lt;/a&gt;. In the final step, we set the user back to 1001, as we don't want our container to run as root. User 1001 is a user that has been added to the UBI Node.js containers as a user suitable for running the application.&lt;/p&gt; &lt;h2&gt;Trying it out&lt;/h2&gt; &lt;p&gt;You can try building and running a sample application with the Dockerfile by following the steps below. For those running on Fedora or RHEL, you can replace the &lt;code&gt;docker&lt;/code&gt; command with &lt;code&gt;podman&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;npx create-next-app --example with-docker myapp cp Dockerfile myapp cp next.config.js myapp cd myapp docker build . -t ubi-nextjs&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This should result in an image tagged with &lt;code&gt;ubi-nextjs:latest&lt;/code&gt;. You can then run that image with:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;​​​​​​​docker run -p 3000:3000 ubi-nextjs&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You should see the following output and then be able to connect with your web browser to port 3000:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;​​​​​​​Listening on port 3000 url: http://localhost:3000&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;You now have your first Next.js application running on the ubi8/nodejs-16 docker image!&lt;/p&gt; &lt;h2&gt;Deployment to OpenShift&lt;/h2&gt; &lt;p&gt;The next step is to build and deploy the Next.js application in OpenShift. There are many other ways to build and deploy in OpenShift—with &lt;a href="https://developers.redhat.com/blog/2021/01/13/getting-started-with-tekton-and-pipelines"&gt;Tekton&lt;/a&gt;, for instance—but for this example we'll stick to one of the easiest: the trio of an &lt;code&gt;ImageStream&lt;/code&gt;, &lt;code&gt;BuildConfig&lt;/code&gt;, and &lt;code&gt;Deployment&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;We'll also need a place to get the application from, and a Git repository is an easy place so that is what we'll use. You can push your Next.js application along with the Dockerfile and Next.js configuration file to a GitHub repository; I used &lt;a href="https://github.com/nodeshift-blog-examples/ubi8-nextjs"&gt;this one&lt;/a&gt;. The &lt;code&gt;BuildConfig&lt;/code&gt; will pull the application from that repository as part of the build.&lt;/p&gt; &lt;p&gt;An &lt;code&gt;ImageStream&lt;/code&gt; provides us an easy place to store our Docker image once it's built. Once you've logged into OpenShift, you can create one by adding the following content to &lt;code&gt;image-stream.yaml&lt;/code&gt; and then running &lt;code&gt;oc apply -f image-stream.yaml&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;kind: ImageStream apiVersion: image.openshift.io/v1 metadata: name: ubi8-nextjs namespace: default&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This will create a new &lt;code&gt;ImageStream&lt;/code&gt; named &lt;code&gt;ubi8-nextjs&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The next step is to create a &lt;code&gt;BuildConfig&lt;/code&gt; that will build our application from the Dockerfile we discussed earlier and push it to the &lt;code&gt;ubi8-nextjs&lt;/code&gt; &lt;code&gt;ImageStream&lt;/code&gt;. You can do that by adding the following content to &lt;code&gt;build-config.yaml&lt;/code&gt; and running &lt;code&gt;oc apply -f build-config.yaml&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: build.openshift.io/v1 kind: BuildConfig metadata: name: ubi8-nextjs labels: app: ubi8-nextjs spec: source: type: Git git: uri: https://github.com/nodeshift-blog-examples/ubi8-nextjs contextDir: strategy: type: Docker dockerStrategy: dockerfilePath: Dockerfile # Look for Dockerfile in: gitUri/contextDir/dockerfilePath output: to: kind: ImageStreamTag name: ubi8-nextjs:latest&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This &lt;code&gt;BuildConfig&lt;/code&gt; will clone the contents of a GitHub repository for your application and then build it using the Dockerfile at the root of the application. Once built, the container is pushed to the &lt;code&gt;ubi8-nextjs&lt;/code&gt; &lt;code&gt;ImageStream&lt;/code&gt; with the tag &lt;code&gt;latest&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;​​​​​​​Once you've applied the YAML for the &lt;code&gt;BuildConfig&lt;/code&gt;, you can go to the OpenShift UI, select the &lt;code&gt;ubi8-next&lt;/code&gt; &lt;code&gt;BuildConfig&lt;/code&gt; and then select &lt;strong&gt;Start build&lt;/strong&gt; under the &lt;strong&gt;Actions&lt;/strong&gt; dropdown, as shown in Figure 1. (Of course you can do this from the command line as well.)&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig1_22.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig1_22.png?itok=SNtT3Q1C" width="600" height="445" alt="Screenshot showing how to start a build from the OpenShift UI." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1: Starting a build. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;Once the build completes, the same Docker image that you built locally earlier is now stored in the &lt;code&gt;ImageStream&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The last step is to deploy the application from the &lt;code&gt;ImageStream&lt;/code&gt;. To do that, we'll use a &lt;code&gt;Deployment&lt;/code&gt;, which we can do either through the UI or some more YAML. The easiest way is through the UI, as it will automatically create additional resources like services that we need to access the application.&lt;/p&gt; &lt;p&gt;Navigate to the &lt;strong&gt;Developer Topology&lt;/strong&gt; view and select the &lt;strong&gt;Add Page&lt;/strong&gt; link. From the &lt;strong&gt;Add&lt;/strong&gt; page, select &lt;strong&gt;Container images&lt;/strong&gt;. From the &lt;strong&gt;Deploy image&lt;/strong&gt; page that pops up (Figure 2), select &lt;strong&gt;Image stream tag from internal registry&lt;/strong&gt;, and then &lt;strong&gt;ubi8-nextjs&lt;/strong&gt; for the &lt;strong&gt;Image Stream&lt;/strong&gt; and &lt;strong&gt;latest&lt;/strong&gt; for the &lt;strong&gt;Tag&lt;/strong&gt;. Scroll down and set the &lt;strong&gt;Target port&lt;/strong&gt; to match the value in our Dockerfile, which is 3000. Accept the rest of the default values and select &lt;strong&gt;Create&lt;/strong&gt;.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig2_15.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig2_15.png?itok=MT201kNB" width="600" height="590" alt="Screenshot showing how to deploy an image from the OpenShift UI." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 2: Deploying an image from the OpenShift UI. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt;You should then return to the &lt;strong&gt;Topology&lt;/strong&gt; page, where you will see the running application, as in Figure 3.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig3_7.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig3_7.png?itok=QjEBgjbk" width="600" height="362" alt="Screenshot showing that the running application is visible on the Topology page." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 3: The running application is visible on the Topology page. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;OpenShift automatically creates the service and route needed to access the application. Just click on the application to get more information and then follow the link provided under &lt;strong&gt;Routes&lt;/strong&gt;, as in Figure 4.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig4_7.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig4_7.png?itok=86i5Kx3e" width="600" height="498" alt="Screenshot showing how to get service and route information for the application." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; ​​​​​​​​​​​​​​Figure 4: Getting service and route information for the application. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;That will take you to the default Next.js starter app that you created earlier. The welcome screen should look like Figure 5.&lt;/p&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="align-center media media--type-image media--view-mode-article-content"&gt;&lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/fig5_6.png" data-featherlight="image"&gt;&lt;img loading="lazy" src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/fig5_6.png?itok=XeIsMBcG" width="600" height="465" alt="Welcome sreen of the default Next.js starter app." typeof="Image" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 5: Default Next.js starter app. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt;&lt;/div&gt; &lt;h2&gt;An easier way&lt;/h2&gt; &lt;p&gt;I've talked you through the "hard way" of deploying this application so you'd understand a bit about &lt;code&gt;ImageStream&lt;/code&gt;s and &lt;code&gt;BuildConfig&lt;/code&gt;s. But in fact, it could have been even easier than that.&lt;/p&gt; &lt;p&gt;We could have simply selected &lt;strong&gt;Import from Git&lt;/strong&gt; on the &lt;strong&gt;Add&lt;/strong&gt; page, provided the URL for our GitHub repository, accepted all the defaults except for setting the target port to 3000, and selected &lt;strong&gt;Create&lt;/strong&gt;. This would have created the &lt;code&gt;ImageStream&lt;/code&gt;, &lt;code&gt;BuildConfig&lt;/code&gt;, &lt;code&gt;Deployment&lt;/code&gt;, service and route automatically for us! You can't get much easier than that.&lt;/p&gt; &lt;h2&gt;Wrapping up&lt;/h2&gt; &lt;p&gt;In this article, you've learned how to build a Next.js application using the Red Hat ubi8 Node.js containers, and how to easily build and deploy that application in OpenShift. If you want to use Next.js and are a Red Hat customer, it's good to know how easy it is to use it with the supported Red Hat Node.js container images and then get it deployed to your OpenShift environment.&lt;/p&gt; &lt;p&gt;If you want to learn more about what Red Hat is up to on the Node.js front, check out &lt;a href="https://developers.redhat.com/topics/nodejs"&gt;our Node.js page&lt;/a&gt;.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/11/23/how-deploy-nextjs-applications-red-hat-openshift" title="How to deploy Next.js applications to Red Hat OpenShift"&gt;How to deploy Next.js applications to Red Hat OpenShift&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Michael Dawson</dc:creator><dc:date>2022-11-23T07:00:00Z</dc:date></entry><entry><title type="html">Quarkus Tools for IntelliJ 1.14.0 released!</title><link rel="alternate" href="https://quarkus.io/blog/intellij-quarkus-tools-1.14.0/" /><author><name>Jeff Maury</name></author><id>https://quarkus.io/blog/intellij-quarkus-tools-1.14.0/</id><updated>2022-11-23T00:00:00Z</updated><content type="html">We are very pleased to announce the 1.14.0 release of Quarkus Tools for IntelliJ. This release adds support for CodeActions and Quick Fixes. CodeActions / Quick Fixes When an error is detected on one of your Quarkus project files, it is highlighted in the source editor (for instance when you...</content><dc:creator>Jeff Maury</dc:creator></entry></feed>
